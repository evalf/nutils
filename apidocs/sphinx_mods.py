# Copyright (c) 2014 Evalf
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import inspect
import pathlib
import shutil
import os
import runpy
import urllib.parse
import shlex
import doctest
import re
import io
import hashlib
import base64
import treelog
import stringly
import docutils.nodes
import docutils.parsers.rst
import docutils.statemachine
import sphinx.util.logging
import sphinx.util.docutils
import sphinx.addnodes
import nutils.matrix
import nutils.testing
import numpy

project_root = pathlib.Path(__file__).parent.parent.resolve()


def process_signature(self, objtype, fullname, object, options, args, retann):
    if objtype in ('function', 'class', 'method'):
        try:
            signature = inspect.signature(object)
        except ValueError:
            # Some builtins have no signature.
            return
    else:
        return
    # Drop annotations from signature.
    signature = signature.replace(parameters=(param.replace(annotation=param.empty) for param in signature.parameters.values()),
                                  return_annotation=inspect.Signature.empty)
    # Return a string representation of args and of the return annotation.  Note
    # that `str(signature)` would have included the return annotation if we
    # hadn't removed it above.
    return str(signature).replace('\\', '\\\\'), ''


def print_rst_autogen_header(*, file, src=None):
    print('..', file=file)
    print('   Automatically generated.  Edits are futile.', file=file)
    print(file=file)
    print(':autogenerated:', file=file)
    if src is not None:
        abssrc = src.resolve().relative_to(project_root)
        print(':autogeneratedfrom: {}'.format(abssrc), file=file)
    print(file=file)


def print_rst_h1(text, *, file):
    assert '\n' not in text
    print(file=file)
    print(text, file=file)
    print('='*len(text), file=file)
    print(file=file)


def print_rst_label(name, *, file):
    print(file=file)
    print('.. _{}:'.format(name), file=file)
    print(file=file)


def copy_utime(src, dst):
    stat = os.stat(str(src))
    os.utime(str(dst), ns=(stat.st_atime_ns, stat.st_mtime_ns))


def generate_examples(app):
    dst_examples = pathlib.Path(app.srcdir)/'examples'
    dst_examples.mkdir(parents=True, exist_ok=True)

    srcs = tuple(f for f in sorted(project_root.glob('examples/*.py')) if f.name != '__init__.py')
    for src in sphinx.util.status_iterator(srcs, 'generating examples... ', 'purple', len(srcs), app.verbosity):
        name = src.name
        dst = dst_examples/(src.with_suffix('.rst').name)

        with dst.open('w', encoding='utf-8') as f_dst:
            print_rst_autogen_header(file=f_dst, src=src)
            # Add a label such that you can reference an example by
            # :ref:`examples/laplace.py`.
            print_rst_label('examples/{}'.format(name), file=f_dst)
            print_rst_h1(name, file=f_dst)
            print('.. exampledoc:: {}'.format(src.relative_to(project_root).as_posix()), file=f_dst)
        copy_utime(src, dst)


class LineIter:

    def __init__(self, lines):
        self._lines = iter(lines)
        self._index = -1
        self._next = None
        self.__next__()

    def __bool__(self):
        return self._next != StopIteration

    def __iter__(self):
        return self

    def __next__(self):
        if self._next == StopIteration:
            raise StopIteration
        value = self._index, self._next
        try:
            self._next = next(self._lines)
            self._index += 1
        except StopIteration:
            self._next = StopIteration
        return value

    @property
    def peek(self):
        if self._next == StopIteration:
            raise ValueError
        else:
            return self._next


class ExampleDocDirective(docutils.parsers.rst.Directive):

    has_content = False
    required_arguments = 1
    options_arguments = 0

    @staticmethod
    def _isdocline(line):
        line = line.lstrip()
        return line.rstrip() == '#' or line.startswith('# ')

    def run(self):
        logger = sphinx.util.logging.getLogger(__name__)
        nodes = []

        src = project_root/self.arguments[0]
        with src.open('r', encoding='utf-8') as f:
            prevtype = None
            lines = LineIter(f)
            if lines and lines.peek.startswith('#!'):
                next(lines)
            while lines:
                if lines.peek.rstrip('\n') == '':
                    next(lines)
                elif self._isdocline(lines.peek):
                    # Collect all doc lines.
                    contents = docutils.statemachine.ViewList()
                    while lines and self._isdocline(lines.peek):
                        i, line = next(lines)
                        contents.append(line.lstrip()[2:], self.arguments[0], i)
                    # Parse as rst into `node`.
                    with sphinx.util.docutils.switch_source_input(self.state, contents):
                        node = docutils.nodes.container()
                        self.state.nested_parse(contents, 0, node)
                    # Process sh roles.  Add links to logs.
                    for sh_node in node.traverse(docutils.nodes.literal):
                        if 'nutils_sh' not in sh_node:
                            continue
                        cmdline = sh_node.get('nutils_sh')
                        cmdline_parts = tuple(shlex.split(cmdline))
                        if cmdline_parts[:2] != ('python3', src.name):
                            logger.warning('Not creating a log for {}.'.format(cmdline))
                            continue
                        log_link = sphinx.addnodes.only(expr='html')
                        log_link.append(docutils.nodes.inline('', ' '))
                        xref = sphinx.addnodes.pending_xref('', reftype='nutils-log', refdomain='std', reftarget=cmdline_parts[2:], script=src)
                        xref += docutils.nodes.inline('', '(view log)', classes=['nutils-log-link'])
                        log_link += xref
                        sh_node.parent.insert(sh_node.parent.index(sh_node)+1, log_link)
                    nodes.extend(node.children)
                else:
                    # Collect all source lines.
                    istart, line = next(lines)
                    contents = [line]
                    while lines and not self._isdocline(lines.peek):
                        i, line = next(lines)
                        contents.append(line)
                    # Remove trailing empty lines.
                    while contents and contents[-1].rstrip('\n') == '':
                        del contents[-1]
                    contents = ''.join(contents)
                    # Create literal block.
                    literal = docutils.nodes.literal_block(contents, contents)
                    literal['language'] = 'python3'
                    literal['linenos'] = True
                    literal['highlight_args'] = dict(linenostart=istart+1)
                    sphinx.util.nodes.set_source_info(self, literal)
                    nodes.append(literal)

        return nodes


def role_sh(name, rawtext, text, lineno, inliner, options={}, context=[]):
    return [docutils.nodes.literal('', text, nutils_sh=text)], []


def create_log(app, env, node, contnode):
    logger = sphinx.util.logging.getLogger(__name__)

    if node['reftype'] == 'nutils-log':
        script = node.get('script')
        scriptname = str(script.relative_to(project_root))

        cmdline_args = node['reftarget']
        cmdline = ' '.join(map(shlex.quote, [scriptname, *cmdline_args]))

        target = '_logs/{}/index'.format(urllib.parse.quote(cmdline, safe='').replace('%', '+'))

        dst_log = (pathlib.Path(app.builder.outdir)/target).parent
        if dst_log.exists() and dst_log.stat().st_mtime > script.stat().st_mtime:
            logger.debug('Skip building log of {cmdline} because it already exists and '
                         'is newer than {script}.  Please touch {script} to force a rebuild.'
                         .format(script=scriptname, cmdline=cmdline))
        else:
            if dst_log.exists():
                logger.debug('purging old log files... {}'.format(dst_log))
                shutil.rmtree(str(dst_log))
            else:
                dst_log.parent.mkdir(parents=True, exist_ok=True)
            logger.info('creating log... {}'.format(cmdline))
            script_dict = runpy.run_path(str(script), run_name='__log_builder__')
            # Parse cmdline.
            func = script_dict['main']
            params = inspect.signature(func).parameters
            doc = stringly.util.DocString(func)
            kwargs = doc.defaults.copy()
            kwargs.update(arg.split('=', 1) for arg in cmdline_args if arg)
            # Run script.
            import matplotlib.testing
            matplotlib.testing.setup()
            with nutils.cli._htmllog(outdir=str(dst_log), scriptname=scriptname, kwargs=[(name, kwargs[name], doc.argdocs[name]) for name in params]) as log, treelog.set(log), nutils.matrix.backend('scipy'), nutils.warnings.via(treelog.warning):
                func(**{name: stringly.loads(params[name].annotation, kwargs[name]) for name in params})
            (dst_log/'log.html').rename(dst_log/'index.html')

        refnode = docutils.nodes.reference('', '', internal=False, refuri=app.builder.get_relative_uri(env.docname, target))
        refnode.append(contnode)
        return refnode


def generate_api(app):
    nutils = project_root/'nutils'
    dst_root = pathlib.Path(app.srcdir)/'nutils'
    dst_root.mkdir(parents=True, exist_ok=True)

    srcs = tuple(f for f in sorted(nutils.glob('**/*.py')) if f != nutils/'__init__.py' and (f.name == '__init__.py' or not f.name.startswith('_')))
    for src in sphinx.util.status_iterator(srcs, 'generating api... ', 'purple', len(srcs), app.verbosity):
        module = '.'.join((src.parent if src.name == '__init__.py' else src.with_suffix('')).relative_to(nutils).parts)
        dst = dst_root/(module+'.rst')
        with dst.open('w', encoding='utf-8') as f:
            print_rst_autogen_header(file=f, src=src)
            print_rst_h1(module, file=f)
            print('.. automodule:: {}'.format('nutils.{}'.format(module)), file=f)
        copy_utime(src, dst)


def remove_generated(app, exception):
    logger = sphinx.util.logging.getLogger(__name__)
    for name in 'nutils', 'examples':
        generated = pathlib.Path(app.srcdir)/name
        shutil.rmtree(str(generated), onerror=lambda f, p, e: logger.warning('failed to remove {}'.format(p)))


class RequiresNode(docutils.nodes.Admonition, docutils.nodes.TextElement):
    pass


def html_visit_requires(self, node):
    self.body.append(self.starttag(node, 'div', CLASS='requires'))


def html_depart_requires(self, node):
    self.body.append('</div>\n')


def text_visit_requires(self, node):
    self.new_state(0)


def text_depart_requires(self, node):
    self.end_state()


class RequiresDirective(docutils.parsers.rst.Directive):

    has_content = False
    required_arguments = 1
    optional_arguments = 0

    def run(self):
        requires = tuple(name.strip() for name in self.arguments[0].split(','))

        node = RequiresNode('requires')
        node.document = self.state.document
        sphinx.util.nodes.set_source_info(self, node)
        msg = 'Requires {}.'.format(', '.join(requires))
        node.append(docutils.nodes.paragraph('', docutils.nodes.Text(msg, msg), translatable=False))
        return [node]


class ConsoleDirective(docutils.parsers.rst.Directive):

    has_content = True
    required_arguments = 0
    options_arguments = 0

    info = treelog.proto.Level.info if hasattr(treelog, 'proto') else 1
    _console_log = treelog.FilterLog(treelog.StdoutLog(), minlevel=info)

    def run(self):
        document = self.state.document
        env = document.settings.env
        nodes = []

        indent = min(len(line)-len(line.lstrip()) for line in self.content)
        code = ''.join(line[indent:]+'\n' for line in self.content)
        code_wo_spread = nutils.testing.FloatNeighborhoodOutputChecker.re_spread.sub(lambda m: m.group(0).split('±', 1)[0], code)

        literal = docutils.nodes.literal_block(code_wo_spread, code_wo_spread, classes=['console'])
        literal['language'] = 'python3'
        literal['linenos'] = False
        sphinx.util.nodes.set_source_info(self, literal)
        nodes.append(literal)

        import matplotlib.testing
        matplotlib.testing.setup()
        import matplotlib.pyplot
        parser = doctest.DocTestParser()
        runner = doctest.DocTestRunner(checker=nutils.testing.FloatNeighborhoodOutputChecker(), optionflags=doctest.ELLIPSIS)
        globs = getattr(document, '_console_globs', {})
        test = parser.get_doctest(code, globs, 'test', env.docname, self.lineno)
        with treelog.set(self._console_log):
            failures, tries = runner.run(test, clear_globs=False)
        for fignum in matplotlib.pyplot.get_fignums():
            fig = matplotlib.pyplot.figure(fignum)
            with io.BytesIO() as f:
                fig.savefig(f, format='svg')
                name = hashlib.sha1(f.getvalue()).hexdigest()+'.svg'
                uri = 'data:image/svg+xml;base64,{}'.format(base64.b64encode(f.getvalue()).decode())
                nodes.append(docutils.nodes.image('', uri=uri, alt='image generated by matplotlib'))
        matplotlib.pyplot.close('all')
        if failures:
            document.reporter.warning('doctest failed', line=self.lineno)
        document._console_globs = test.globs

        return nodes


def remove_console_globs(app, doctree):
    if hasattr(doctree, '_console_globs'):
        del doctree._console_globs


def fix_testcase_reference(app, env, node, contnode):
    if node['reftarget'] == 'unittest.case.TestCase':
        node = node.deepcopy()
        node['reftarget'] = 'unittest.TestCase'
        return app.emit_firstresult('missing-reference', env, node, contnode)


def setup(app):
    app.connect('autodoc-process-signature', process_signature)

    app.connect('builder-inited', generate_api)

    app.connect('builder-inited', generate_examples)
    app.add_directive('exampledoc', ExampleDocDirective)
    app.add_role('sh', role_sh)
    app.connect('missing-reference', create_log)

    app.add_node(RequiresNode,
                 html=(html_visit_requires, html_depart_requires),
                 text=(text_visit_requires, text_depart_requires))
    app.add_directive('requires', RequiresDirective)

    app.add_directive('console', ConsoleDirective)
    app.connect('doctree-read', remove_console_globs)

    app.connect('build-finished', remove_generated)

    app.connect('missing-reference', fix_testcase_reference)

    if sphinx.version_info >= (1, 8):
        app.add_css_file('mods.css')
    else:
        app.add_stylesheet('mods.css')

# vim: sts=2:sw=2:et
