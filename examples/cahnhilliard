#! /usr/bin/env python

from nutils import *


@log.title
def makeplots( domain, geom, c, mu, energies, nsteps ):

  force = mu * c.grad(geom)
  xpnt, cpnt = domain.elem_eval( [ geom, c ], ischeme='bezier4', title='mesh', separate=True )
  xy, uv = domain.elem_eval( [ geom, force ], ischeme='uniform1', title='quiver', separate=False )
  Emix, Eiface, Ewall = numpy.array(energies).T

  with plot.PyPlot( 'concentration', ndigits=4, index=len(energies) ) as plt:
    plt.mesh( xpnt, cpnt )
    plt.colorbar()
    plt.clim( -1, 1 )
    plt.quiver( xy[:,0], xy[:,1], uv[:,0], uv[:,1], pivot='middle' )
    ax = plt.gca()
    ax.set_xticks([])
    ax.set_yticks([])
    ax = plt.axes( [.07,.05,.35,.25], axisbg='w' )
    ax.patch.set_alpha( .8 )
    for E, c, name in (Emix+Eiface+Ewall,'b','total'), (Emix,'r','mixture'), (Eiface,'g','interface'), (Ewall,'y','wall'):
      plt.plot( E, '-'+c )
      plt.plot( len(E)-1, E[-1], c+'o', label=name )
    plt.legend( numpoints=1, frameon=False, fontsize=8 )
    plt.xlim( 0, nsteps )
    plt.ylim( 0, Emix[0] + Eiface[0] )
    ax.set_xticks([])
    ax.set_yticks([])
    plt.xlabel( 'time' )
    plt.ylabel( 'energy' )


def main( nelems=20, epsilon=None, timestep=.01, maxtime=1., theta=90, init='random', plot=True ):

  mineps = 1./nelems
  nsteps = numeric.round( maxtime / timestep )
  ewall = .5 * numpy.cos( theta * numpy.pi / 180 )

  if epsilon is None:
    log.info( 'setting epsilon=%f' % mineps )
    epsilon = mineps
  elif epsilon < mineps:
    log.warning( 'epsilon under crititical threshold: %f < %f' % ( epsilon, mineps ) )

  xnodes = ynodes = numpy.linspace(0,1,nelems+1)
  domain, geom = mesh.rectilinear( [ xnodes, ynodes ] )

  cbasis, mubasis = function.chain([ domain.basis( 'spline', degree=2 ), domain.basis( 'spline', degree=2 ) ])

  # mixing energy and splitting: F' = f_p - f_n
  F = lambda c_: (.5/epsilon**2) * (c_**2-1)**2
  f_p = lambda c_: (1./epsilon**2) * 4*c_
  f_n = lambda c_: (1./epsilon**2) * ( 6*c_ - 2*c_**3 )

  A = function.outer( cbasis ) \
    + (timestep*epsilon**2) * function.outer( cbasis.grad(geom), mubasis.grad(geom) ).sum(-1) \
    + function.outer( mubasis, mubasis - f_p(cbasis) ) \
    - function.outer( mubasis.grad(geom), cbasis.grad(geom) ).sum(-1)

  matrix = domain.integrate( A, geometry=geom, ischeme='gauss4' )
  rhs0 = domain.boundary.integrate( mubasis * ewall, geometry=geom, ischeme='gauss4' )

  if init == 'random':
    numpy.random.seed( 0 )
    c = cbasis.dot( numpy.random.normal(0,.5,cbasis.shape) )
  elif init == 'bubbles':
    R1 = .25
    R2 = numpy.sqrt(.5) * R1 # area2 = .5 * area1
    c = 1 + function.tanh( (R1-function.norm2(geom-(.5+R2/numpy.sqrt(2)+.8*epsilon)))/epsilon ) \
          + function.tanh( (R2-function.norm2(geom-(.5-R1/numpy.sqrt(2)-.8*epsilon)))/epsilon )
  else:
    raise Exception( 'unknown init %r' % init )

  energies = []

  for istep in log.range( 'timestep', nsteps ):

    b = cbasis * c - mubasis * f_n(c)
    Emix = F(c)
    Eiface = .5 * (c.grad(geom)**2).sum(-1)
    Ewall = ( abs(ewall) + ewall * c )

    rhs, total, energy_mix, energy_iface = domain.integrate( [ b, c, Emix, Eiface ], geometry=geom, ischeme='gauss4' )
    energy_wall = domain.boundary.integrate( Ewall, geometry=geom, ischeme='gauss4' )
    log.user( 'concentration {}, energy {}'.format( total, energy_mix + energy_iface + energy_wall ) )
    energies.append(( energy_mix, energy_iface, energy_wall ))

    lhs = matrix.solve( rhs0 + rhs, tol=1e-12, restart=999 )
    c = cbasis.dot( lhs )
    mu = mubasis.dot( lhs )

    if plot:
      makeplots( domain, geom, c, mu, energies, nsteps )

  return lhs, energies


def unittest():

  retvals = main( nelems=8, init='bubbles', maxtime=.1, plot=False )
  assert debug.checkdata( retvals, '''
    eNptlVmSIjEMRK/TEwETlqz1QH3/K4xLGwVD9IdcwvWcmTI0PH7oAfzn8fNjrPr7pIex8VUVwa/KBPb7
    5MdTF+2r8TTfsePpG7LjhKsWgm+Lphk7JJXiFAGCom5oKjVVmsrfqa2taaxosUFsSWLRsbCQfEfW4osX
    bWsv5G51xA2OFNOpmqU46yOP7vK+pBZA2Is0MNGN29H3AvZbyp5BiKjXYudZCga9sPdZTHxjeBQOcEMC
    wTM+1KzAalk3fgx2ZtHpjd1W1zBVilOMOJ4NMw5DpM9L0nOdSXR07bSVNcwXhynzgnvl+N/VuE11Aq3U
    2uYoa5imSZO5GF+g8jHSmkBn1jZbWcNMMD5ngPicheM9Zj91PwDs7MPDAc56cU4lhKh7aVS8FESNfc0R
    8F1cTZ5L8YqLUjwsnn3worae4SzJ87n0Kax8vs4LXnEkK4i/13pv9NSzeVVOXyKpi0rvOSjqWl7V3vOB
    dz3NsZ37xMqnxn5X3pcf8YVRzeJ5cu582lfraQ7Xcwz+5KSa+Wjyzn6O2vPqnDuf9lV6hhNfm32+lIvy
    KhPrig4JpMQe/Yyso86I2lpLeqGO9hD3BOBwdS3829hnXBV3x9T2XqpeKE2nZ7HhfiW/MEPvRF5RjcFR
    NaizoFhc/5EAua9S8Nffqw1bIhXbHrTqUmali9+6eUkErx/Z6e68iufnYN+7NRiiOwEt9HB4e3VXZMFA
    eutCjpqPiVt3UWjgnYlG9/z9AzNTnmg=''' )


util.run( main, unittest )
