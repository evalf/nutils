#! /usr/bin/env python

from __future__ import division
from nutils import *


@log.title
def makeplots( domain, geom, velo, pres, index, plts ):

  vort = velo.grad(geom)[1,0] - velo.grad(geom)[0,1]
  xlim = -4, 14
  ylim = -5, 5
  xy, uv = domain.elem_eval( [ geom, velo ], ischeme='uniform1', separate=False )
  points, flow, pres, vort = domain.elem_eval( [ geom, function.norm2(velo), pres, vort ], ischeme='bezier5', separate=True )

  if plts is True:
    plts = [ plot.PyPlot( name, index=index ) for name in [ 'flow', 'pres', 'vort' ] ]

  with plts[0] as plt:
    plt._pyplot.figure(plt._fig.number)
    plt.mesh( points, flow, triangulate='bezier' )
    plt.colorbar( orientation='horizontal' )
    plt.xlim( xlim )
    plt.ylim( ylim )
    plt.quiver( xy[:,0], xy[:,1], uv[:,0], uv[:,1] )

  with plts[1] as plt:
    plt._pyplot.figure(plt._fig.number)
    plt.mesh( points, pres, triangulate='bezier' )
    plt.colorbar( orientation='horizontal' )
    plt.xlim( xlim )
    plt.ylim( ylim )
    plt.quiver( xy[:,0], xy[:,1], uv[:,0], uv[:,1] )

  with plts[2] as plt:
    plt._pyplot.figure(plt._fig.number)
    plt.mesh( points, vort, triangulate='bezier' )
    plt.colorbar( orientation='horizontal' )
    plt.xlim( xlim )
    plt.ylim( ylim )
    plt.quiver( xy[:,0], xy[:,1], uv[:,0], uv[:,1] )


def main( nelems=24, viscosity=1e-3, density=1, tol=1e-8, rotation=0, timestep=.1, maxradius=50, plt=True ):

  if plt == 'video':
    plt = [ plot.PyPlotVideo( name ) for name in [ 'flow', 'pres', 'vort' ] ]

  rscale = 2*numpy.pi / nelems
  melems = numpy.ceil( numpy.log(maxradius) / rscale ).astype( int )

  log.info( 'creating {}x{} mesh, outer radius {:.2f}'.format( melems, nelems, numpy.exp( rscale * melems ) ) )

  domain, (rho,phi) = mesh.rectilinear( [range(melems+1),numpy.linspace(0,2*numpy.pi,nelems+1)], periodic=(1,) )
  normal, tangent = function.rotmat(phi)
  radius = function.exp( rscale * rho )
  geom = radius * normal
  cylvelo = rotation * tangent

  vbasis = function.vectorize([ domain.basis( 'spline', degree=(2,1), removedofs=((0,),None) ), domain.basis( 'spline', degree=(1,2) ) ])
  pbasis = domain.basis( 'spline', degree=1 )

  # piola
  J = function.localgradient( geom, domain.ndims )
  detJ = function.determinant( J )
  vbasis = ( vbasis[...,_,:] * J ).sum(-1) / detJ
  pbasis = pbasis / detJ

  vbasis, pbasis, lbasis = function.chain([ vbasis, pbasis, [1.] ])
  stressbasis = (2*viscosity) * vbasis.symgrad(geom) - pbasis[:,_,_] * function.eye( domain.ndims )

  # stokes
  A = function.outer( vbasis.grad(geom), stressbasis ).sum([2,3]) \
    + function.outer( pbasis, vbasis.div(geom)+lbasis ) \
    + function.outer( lbasis, pbasis )
  At = (density/timestep) * function.outer( vbasis ).sum(-1)
  stokesmat, inertmat = domain.integrate( [ A, At ], geometry=geom, ischeme='gauss9' )

  # tangential flow boundary condition
  h = function.ElementSize( geom, -1 )
  nietzsche = (10*viscosity/h) * vbasis - stressbasis.dotnorm(geom)
  B = function.outer( nietzsche, vbasis ).sum(-1)
  b = ( nietzsche * cylvelo ).sum(-1)
  bcondmat, rhs = domain.boundary['left'].integrate( [ B, b ], geometry=geom, ischeme='gauss9' )
  stokesmat += bcondmat

  cons = domain.boundary['right'].project( [1,0], geometry=geom, onto=vbasis, ischeme='gauss9', tol=1e-12 )
  lhs = stokesmat.solve( rhs, constrain=cons, tol=tol, restart=9999, precon='spilu' )

  stokesmat += inertmat
  for iiter in log.count( 'timestep' ):
    makeplots( domain, geom, vbasis.dot(lhs), pbasis.dot(lhs), iiter, plt )
    convection = density * ( vbasis.grad(geom) * vbasis.dot(lhs) ).sum(-1)
    matrix = stokesmat + domain.integrate( function.outer( vbasis, convection ).sum(-1), ischeme='gauss9', geometry=geom )
    lhs = matrix.solve( rhs + inertmat.matvec(lhs), lhs0=lhs, constrain=cons, tol=tol, restart=9999, precon='spilu' )
  

def unittest():

  pass


util.run( main, unittest )
